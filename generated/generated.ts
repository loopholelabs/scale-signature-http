// Code generated by protoc-gen-ts-polyglot 0.2.0. DO NOT EDIT.
import { encodeString, decodeString, encodeInt64, decodeInt64, encodeUint8Array, decodeUint8Array, encodeInt32, decodeInt32, encodeMap, Kind, decodeMap, encodeArray, decodeArray } from "@loopholelabs/polyglot-ts";


export class Request {
    constructor(Method: string, ContentLength: bigint, Protocol: string, IP: string, Body: Uint8Array, Headers: Map<string, StringList>) {
        this._Method = Method
        this._ContentLength = ContentLength
        this._Protocol = Protocol
        this._IP = IP
        this._Body = Body
        this._Headers = Headers
    }

    private _Method: string;

    get Method(): string {
        return this._Method
    }

    set Method(Method: string) {
        this._Method = Method
    }

    private _ContentLength: bigint;

    get ContentLength(): bigint {
        return this._ContentLength
    }

    set ContentLength(ContentLength: bigint) {
        this._ContentLength = ContentLength
    }

    private _Protocol: string;

    get Protocol(): string {
        return this._Protocol
    }

    set Protocol(Protocol: string) {
        this._Protocol = Protocol
    }

    private _IP: string;

    get IP(): string {
        return this._IP
    }

    set IP(IP: string) {
        this._IP = IP
    }

    private _Body: Uint8Array;

    get Body(): Uint8Array {
        return this._Body
    }

    set Body(Body: Uint8Array) {
        this._Body = Body
    }

    private _Headers: Map<string, StringList>;

    get Headers(): Map<string, StringList> {
        return this._Headers
    }

    set Headers(Headers: Map<string, StringList>) {
        this._Headers = Headers
    }

    encode(buf: Uint8Array): Uint8Array {
        let encoded = buf
        encoded = encodeString(encoded, this._Method)
        encoded = encodeInt64(encoded, this._ContentLength)
        encoded = encodeString(encoded, this._Protocol)
        encoded = encodeString(encoded, this._IP)
        encoded = encodeUint8Array(encoded, this._Body)
        encoded = encodeMap(encoded, this._Headers.size,
                      Kind.String, Kind.Any)
        this._Headers.forEach((value, key) => {
                          encoded = encodeString(encoded, key);
                          encoded = value.encode(encoded);
                        })
        return encoded
    }

    static decode(buf: Uint8Array): {
              buf: Uint8Array,
              value: Request
            } {
        let decoded = buf
        const Method = decodeString(decoded)
        decoded = Method.buf
        const ContentLength = decodeInt64(decoded)
        decoded = ContentLength.buf
        const Protocol = decodeString(decoded)
        decoded = Protocol.buf
        const IP = decodeString(decoded)
        decoded = IP.buf
        const Body = decodeUint8Array(decoded)
        decoded = Body.buf
        const HeadersMap = decodeMap(decoded)
        decoded = HeadersMap.buf
        const Headers: { value: Map<string, StringList> } = {
                          value: new Map<string, StringList>(),
                        }

        for (let i = 0; i < HeadersMap.size; i++) {
                          const key = decodeString(decoded);
                          decoded = key.buf;
                          const value = StringList.decode(decoded);
                          decoded = value.buf;
                          Headers.value.set(key.value, value.value);
                        }

        return {
              buf: decoded,
              value: new Request(Method.value,ContentLength.value,Protocol.value,IP.value,Body.value,Headers.value)
            }
    }
}

export class Response {
    constructor(StatusCode: number, Body: Uint8Array, Headers: Map<string, StringList>) {
        this._StatusCode = StatusCode
        this._Body = Body
        this._Headers = Headers
    }

    private _StatusCode: number;

    get StatusCode(): number {
        return this._StatusCode
    }

    set StatusCode(StatusCode: number) {
        this._StatusCode = StatusCode
    }

    private _Body: Uint8Array;

    get Body(): Uint8Array {
        return this._Body
    }

    set Body(Body: Uint8Array) {
        this._Body = Body
    }

    private _Headers: Map<string, StringList>;

    get Headers(): Map<string, StringList> {
        return this._Headers
    }

    set Headers(Headers: Map<string, StringList>) {
        this._Headers = Headers
    }

    encode(buf: Uint8Array): Uint8Array {
        let encoded = buf
        encoded = encodeInt32(encoded, this._StatusCode)
        encoded = encodeUint8Array(encoded, this._Body)
        encoded = encodeMap(encoded, this._Headers.size,
                      Kind.String, Kind.Any)
        this._Headers.forEach((value, key) => {
                          encoded = encodeString(encoded, key);
                          encoded = value.encode(encoded);
                        })
        return encoded
    }

    static decode(buf: Uint8Array): {
              buf: Uint8Array,
              value: Response
            } {
        let decoded = buf
        const StatusCode = decodeInt32(decoded)
        decoded = StatusCode.buf
        const Body = decodeUint8Array(decoded)
        decoded = Body.buf
        const HeadersMap = decodeMap(decoded)
        decoded = HeadersMap.buf
        const Headers: { value: Map<string, StringList> } = {
                          value: new Map<string, StringList>(),
                        }

        for (let i = 0; i < HeadersMap.size; i++) {
                          const key = decodeString(decoded);
                          decoded = key.buf;
                          const value = StringList.decode(decoded);
                          decoded = value.buf;
                          Headers.value.set(key.value, value.value);
                        }

        return {
              buf: decoded,
              value: new Response(StatusCode.value,Body.value,Headers.value)
            }
    }
}

export class StringList {
    constructor(Value: string[]) {
        this._Value = Value
    }

    private _Value: string[];

    get Value(): string[] {
        return this._Value
    }

    set Value(Value: string[]) {
        this._Value = Value
    }

    encode(buf: Uint8Array): Uint8Array {
        let encoded = buf
        encoded = encodeArray(encoded, this._Value.length, Kind.String)
        this._Value.forEach(field => {
                          encoded = encodeString(encoded, field);
                        })
        return encoded
    }

    static decode(buf: Uint8Array): {
              buf: Uint8Array,
              value: StringList
            } {
        let decoded = buf
        const ValueArray = decodeArray(decoded)
        decoded = ValueArray.buf
        const Value: { value: string[] } = {
                          value: [],
                        }

        for (let i = 0; i < ValueArray.size; i++) {
                          const element = decodeString(decoded);
                          decoded = element.buf;
                          Value.value.push(element.value);
                        }

        return {
              buf: decoded,
              value: new StringList(Value.value)
            }
    }
}

export class Context {
    constructor(Request: Request, Response: Response) {
        this._Request = Request
        this._Response = Response
    }

    private _Request: Request;

    get Request(): Request {
        return this._Request
    }

    set Request(Request: Request) {
        this._Request = Request
    }

    private _Response: Response;

    get Response(): Response {
        return this._Response
    }

    set Response(Response: Response) {
        this._Response = Response
    }

    encode(buf: Uint8Array): Uint8Array {
        let encoded = buf
        encoded = this._Request.encode(encoded)
        encoded = this._Response.encode(encoded)
        return encoded
    }

    static decode(buf: Uint8Array): {
              buf: Uint8Array,
              value: Context
            } {
        let decoded = buf
        const Req = Request.decode(decoded)
        decoded = Req.buf
        const Resp = Response.decode(decoded)
        decoded = Resp.buf
        return {
              buf: decoded,
              value: new Context(Req.value,Resp.value)
            }
    }
}
